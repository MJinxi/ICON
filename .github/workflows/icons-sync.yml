name: Icons JSON Sync
on:
  push:
    paths:
      - 'icons/**'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - uses: actions/checkout@v4
      with:
        # fetch full history so we can safely pull/rebase and push
        fetch-depth: 0
        # keep credentials so later git push can use the provided token
        persist-credentials: true

    - name: Generate JSON files from icons/
      run: |
        set -euo pipefail
        mkdir -p JSON
        for dir in icons/*; do
          [ -d "$dir" ] || continue
          folder=$(basename "$dir")
          outfile="JSON/${folder}.json"
          # create base JSON（说明改为“应用图标库”以保持一致）
          echo "{\"name\": \"${folder}\", \"description\": \"适用于${folder}的应用图标库\", \"icons\": []}" > "$outfile"
          # 递归查找目录下的图片文件（支持多层目录）并以 NUL 分隔传输文件名以兼容空格
          while IFS= read -r -d '' icon; do
            [ -f "$icon" ] || continue
            # 只处理常见的图片扩展名，忽略其他文件
            ext="${icon##*.}"
            case "${ext,,}" in
              png|jpg|jpeg|svg|ico) ;;
              *) continue ;;
            esac
            base=$(basename "$icon")
            iconName="${base%.*}"
            # 使用相对仓库路径生成 raw.githubusercontent URL
            url="https://raw.githubusercontent.com/MJinxi/ICON/main/$icon"
            jq --arg iconName "$iconName" --arg url "$url" '.icons += [{"name": $iconName, "url": $url}]' "$outfile" > tmp.json && mv tmp.json "$outfile"
          done < <(find "$dir" -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.svg" -o -iname "*.ico" \) -print0)
        done

    - name: Commit JSON updates
      run: |
        set -euo pipefail
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add JSON/*.json || true
        if git diff --staged --quiet; then
          echo "No JSON changes to commit"
          exit 0
        fi

        git commit -m "Update icons JSON files"

        # determine branch name (e.g., refs/heads/main -> main)
        branch="${GITHUB_REF#refs/heads/}"

        # fetch latest remote branch and rebase to avoid non-fast-forward errors
        git fetch origin "$branch"
        git rebase "origin/$branch" || {
          echo "Rebase failed, attempting to abort and merge instead"
          git rebase --abort || true
          git pull --no-rebase --no-edit origin "$branch"
        }

        # push changes
        git push origin "HEAD:$branch"
